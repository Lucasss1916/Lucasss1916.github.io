<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSharp on Lucas`s blog</title><link>https://lucasss1916.github.io/tags/csharp/</link><description>Recent content in CSharp on Lucas`s blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 23 Dec 2025 12:51:00 +0800</lastBuildDate><atom:link href="https://lucasss1916.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Csharp委托和事件</title><link>https://lucasss1916.github.io/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</link><pubDate>Tue, 23 Dec 2025 12:51:00 +0800</pubDate><guid>https://lucasss1916.github.io/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</guid><description>&lt;h1 id="1-csharp委托delegate"&gt;1. Csharp委托（Delegate）&lt;/h1&gt;
&lt;h2 id="11-委托的定义"&gt;1.1. 委托的定义&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;public delegate void newDelegate(string message);
public delegate int CalculateDelegate(int x, int y);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="12-使用委托"&gt;1.2. 使用委托&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; // 声明委托
 delegate void PrintDelegate(string text);
 
 static void Main()
 {
 // 1. 传统方式实例化委托
 PrintDelegate printer = new PrintDelegate(PrintMessage);
 printer(&amp;#34;Hello, World!&amp;#34;);
 
 // 2. 简化语法（C# 2.0+）
 PrintDelegate printer2 = PrintMessage;
 printer2(&amp;#34;Hello from simplified syntax!&amp;#34;);
 
 // 3. 匿名方法（C# 2.0）
 PrintDelegate printer3 = delegate(string text)
 {
 Console.WriteLine(&amp;#34;Anonymous method: &amp;#34; + text);
 };
 printer3(&amp;#34;Testing anonymous method&amp;#34;);
 
 // 4. Lambda表达式（C# 3.0+）
 PrintDelegate printer4 = (text) =&amp;gt; Console.WriteLine(&amp;#34;Lambda: &amp;#34; + text);
 printer4(&amp;#34;Testing lambda expression&amp;#34;);
 }
 static void PrintMessage(string message)
 {
 Console.WriteLine(message);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="13-多播委托"&gt;1.3. 多播委托&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class MulticastDelegateExample
{
	delegate void ProgressDelegate(int perfect);
	static void main()
	{
		ProgressDelegate progress =null;
		//添加多个方法到委托
		progress += UpdateProgressBar;
		progress += LogProgress;
		progress += ShowNotification;
		
		progress(50);
		progress -=LogProgess;
		Console.WriteLine(&amp;#34;\nAfter removing LogProgress: &amp;#34;);
		progress(75);
	}
	static void UpdateProgressBar(int percant)
	{
		 Console.writeLine($&amp;#34;Progress bar updated :{percent}%&amp;#34;)
	}
	static void LogProgress(int percent)
 {
 Console.WriteLine($&amp;#34;Logging progress: {percent}%&amp;#34;);
 }
 static void ShowNotification(int percent)
 {
 Console.WriteLine($&amp;#34;Notification: Task is {percent}% complete&amp;#34;);
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="14-内置委托类型"&gt;1.4. 内置委托类型&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;static void Main()
{
	//1.Action&amp;lt;T&amp;gt; - 无返回值的方法
	Action&amp;lt;string&amp;gt; action1 = Console.WriteLine;
	Action&amp;lt;int ,int&amp;gt; action2 =(x,y)=&amp;gt; Console.WriteLine($&amp;#34;sum: {x+y}&amp;#34;);
	action1(&amp;#34;Hello Action!&amp;#34;);
	action2(10,20);
 // 2. Func&amp;lt;T, TResult&amp;gt; - 有返回值的方法
 Func&amp;lt;int, int, int&amp;gt; add = (x, y) =&amp;gt; x + y;
 Func&amp;lt;string, string&amp;gt; upper = s =&amp;gt; s.ToUpper();
 
 Console.WriteLine($&amp;#34;Add result: {add(5, 3)}&amp;#34;);
 Console.WriteLine($&amp;#34;Upper: {upper(&amp;#34;hello&amp;#34;)}&amp;#34;);
	//3.Predicate&amp;lt;T&amp;gt; - 返回bool的方法
	Predicate&amp;lt;int&amp;gt; isEven =x =&amp;gt;x % 2 ==0
	int[] numbers ={1,2,3,4,5};
	
	var evenNumbers= Array.FindAll(numbers,isEven);
	Console.WriteLine($&amp;#34;Even Numbers :{string.Join(&amp;#34;,&amp;#34;,evenNumbers)}&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="15-委托作为参数"&gt;1.5. 委托作为参数&lt;/h2&gt;</description></item><item><title>GC</title><link>https://lucasss1916.github.io/post/gc/</link><pubDate>Tue, 19 Aug 2025 21:56:01 +0800</pubDate><guid>https://lucasss1916.github.io/post/gc/</guid><description>&lt;h1 id="1-什么是gc"&gt;1. 什么是GC&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;是自动内存管理机制，负责自动释放不再使用的内存，防止内存泄漏。&lt;/p&gt;
&lt;h1 id="2-基本概念"&gt;2. 基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;根对象&lt;/strong&gt;：静态字段、局部变量、CPU寄存器等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可达性&lt;/strong&gt;：从根对象直接或间接引用的对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代际理论&lt;/strong&gt;：对象生存期越短，越应该被快速回收&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="3-netunity三代gc"&gt;3. Net/Unity三代GC&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Generation 0 ：新创建的对象15:01&lt;/li&gt;
&lt;li&gt;Generation 1 ：存货过一次的gc对象&lt;/li&gt;
&lt;li&gt;Generation 2: 长期存活的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="4-gc触发时机"&gt;4. GC触发时机&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;第0代满时&lt;/li&gt;
&lt;li&gt;手动调用GC.Collect（）&lt;/li&gt;
&lt;li&gt;系统内存不足&lt;/li&gt;
&lt;li&gt;应用程序卸载域&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="5-主要gc来源"&gt;5. 主要GC来源&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;using UnityEngine;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;using System.Collections;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;public class GCExample : MonoBehaviour&lt;/code&gt;&lt;br&gt;
&lt;code&gt;{&lt;/code&gt;&lt;br&gt;
&lt;code&gt;void Update()&lt;/code&gt;&lt;br&gt;
&lt;code&gt;{&lt;/code&gt;&lt;br&gt;
&lt;code&gt;// 1. 字符串拼接&lt;/code&gt;&lt;br&gt;
&lt;code&gt;string result = &amp;quot;Score: &amp;quot; + score + &amp;quot; Time: &amp;quot; + time; // 产生GC&lt;/code&gt;&lt;br&gt;
&lt;code&gt;// 2. 装箱操作&lt;/code&gt;&lt;br&gt;
&lt;code&gt;int number = 42;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;object boxed = number; // 装箱，产生GC&lt;/code&gt;&lt;br&gt;
&lt;code&gt;// 3. LINQ查询&lt;/code&gt;&lt;br&gt;
&lt;code&gt;var filtered = someList.Where(x =&amp;gt; x &amp;gt; 10).ToList(); // 产生GC&lt;/code&gt;&lt;br&gt;
&lt;code&gt;// 4. 匿名方法/Lambda&lt;/code&gt;&lt;br&gt;
&lt;code&gt;someList.ForEach(x =&amp;gt; Debug.Log(x)); // 可能产生GC&lt;/code&gt;&lt;br&gt;
&lt;code&gt;// 5. 数组分配&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Vector3[] tempArray = new Vector3[100]; // 产生GC&lt;/code&gt;&lt;br&gt;
&lt;code&gt;}&lt;/code&gt;&lt;br&gt;
&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;</description></item></channel></rss>