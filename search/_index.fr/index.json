[{"categories":[{"LinkTitle":"学习","RelPermalink":"/categories/%E5%AD%A6%E4%B9%A0/"},{"LinkTitle":"Unity","RelPermalink":"/categories/unity/"}],"content":"ChatGPT提供的学习路线\n看懂大部分 Unity 游戏 Shader 自己实现常见游戏效果 知道效果该用 Shader、还是粒子、还是后处理 阶段0 需要储备的基础知识，可以学习的补肾，但一定要会 向量：flaot2 float3 float4 dot normalize length lerp clamp saturate 基本三角函数 阶段1 Unlit Shader 学习目标：\n理解shader在“干什么” 建立“GPU思维” 会写简单视觉变化 必须会的效果： 纯色/渐变 UV操作 平移/缩放 滚动纹理（水流，能量条） 基于时间的动画 遮罩 圆形/条形 血条，冷却条，范围提示 阶段2 基础光照 游戏光照≠真实光照 必须手写的光照模型\nLambert 理解：明暗分界线 、模型体积感 Blinn-Phong 理解： 高光位置 、材质区分感 阶段3 贴图 albedo/Normal/Mask 为什么法线贴图是紫色 为什么要normal * 2-1 Mask一张图塞4个通道 法线贴图 + 光照 TBN是干嘛的 不用手推矩阵，但直到意义 游戏常用技巧 用贴图假装细节 不用增加面数 不增加计算 阶段4 游戏shader的“灵魂技巧” 必学效果\nFresnel 角色边缘光 技能轮廓 能量护盾 Rim Light 强化轮廓 提升角色可读性 Dissolve（溶解） 出生/消失 传送 技能效果 Distortion（扭曲） 热浪 能量波 空气震荡 阶段5 透明 、半透明、特效shader 必须理解：\nAlpha Blend Additive Depth 游戏特效核心： 粒子+shader BillBoard UV动画 soft particle 阶段6 后处理 必学后处理\nBloom（亮部扩散） Color Grading （色调） Vignette 简单Blur 阶段7 Shader Graph 用 Graph 快速试效果 读生成的 HLSL 自己改关键逻辑 ","permalink":"https://lucasss1916.github.io/post/%E6%B8%B8%E6%88%8F%E5%90%91shader%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","tags":[{"LinkTitle":"学习","RelPermalink":"/tags/%E5%AD%A6%E4%B9%A0/"},{"LinkTitle":"Unity","RelPermalink":"/tags/unity/"},{"LinkTitle":"Shader","RelPermalink":"/tags/shader/"}],"title":"游戏向shader的学习路线"},{"categories":[{"LinkTitle":"Unity","RelPermalink":"/categories/unity/"}],"content":"从0开始学习shader ","permalink":"https://lucasss1916.github.io/post/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8/","tags":[{"LinkTitle":"Unity","RelPermalink":"/tags/unity/"},{"LinkTitle":"Shader","RelPermalink":"/tags/shader/"}],"title":"记录学习片元着色器"},{"categories":[{"LinkTitle":"学习","RelPermalink":"/categories/%E5%AD%A6%E4%B9%A0/"}],"content":"1. 使用AI模型搭配MCP重构项目 JetBrains的IDE提供内置的MCP server功能，通过MCP协议，ai模型可以直接通过IDE查看代码，并进行更改，使用get_symbol_info 和 rename_refactoring\n1.1. get_symbol_info 在传统ai中，ai通过阅读代码，或将整个代码复制给AI阅读，如果需要理解上下文，还需要将有关联的代码复制给他，才可以理解，但是有了MCP，它就可以通过调用get_symbol_info来读取函数的定义、参数类型、注释文档，甚至可以看到该函数是在哪里被定义的。 得益于Jetbrains的索引能力，静态分析能力，提供给AI100%准确的符号信息，而不是靠AI自己猜测。\n1.2. rename_refactoring 这是最关键的重构工具，与“查找并替换”不同，调用IDE内部的重构引擎(Refactoring Engine)，当AI模型需要改名时，不是自己生成一个新文本，而是向IDE发送一个指令：“请对该变量进行重命名操作”。\n1.2.1. 为什么适用于Jetbrains 上下文感知：如果你的项目里有两个不同类都有 id 这个变量，普通的 AI 生成代码可能会搞混，导致全都改了。但 rename_refactoring 通过 IDE 的 PSI (程序结构接口) 知道只改你指定的那个类的 id。 全项目更新：它会自动更新所有的导入路径（imports）、注释中的引用、甚至是 XML/YAML 配置文件中的引用（如果 IDE 支持）。 1.3. 工作流程 1.3.1. 输入提示词 “请检查User.cs中的uid变量，命名太模糊，根据他的用途重构一个更为清晰的名字。”\n1.3.2. AI工具思考调用 第一步 (观察)： 调用 get_symbol_info 查看 uid 的定义和用法。Claude 发现它是一个 String 类型的用户唯一标识符。 第二步 (决策)： Claude 决定将其重命名为 userUniqueId。 第三步 (行动)： 调用 rename_refactoring，传入文件路径和新名字 userUniqueId。 1.3.3. IDE执行 IDE 接收到指令，弹出（或静默执行）重构预览。 IDE 确保这次修改是安全的（不报错、不冲突）。 IDE 修改所有引用了该变量的文件。 1.3.4. 返回结果 Claude 返回消息：\u0026ldquo;已成功将 uid 重命名为 userUniqueId，并更新了 15 处引用。\u0026rdquo;\n","permalink":"https://lucasss1916.github.io/post/%E4%BD%BF%E7%94%A8ai%E6%90%AD%E9%85%8Dide%E7%9A%84mcp%E9%87%8D%E6%9E%84%E9%A1%B9%E7%9B%AE/","tags":[{"LinkTitle":"学习","RelPermalink":"/tags/%E5%AD%A6%E4%B9%A0/"},{"LinkTitle":"AI","RelPermalink":"/tags/ai/"}],"title":"使用AI搭配IDE的MCP重构项目"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. 什么是四元数？ 四元数是一种表示三维空间旋转的数学工具，与欧拉角相比，它可以避免\u0026quot;万向节锁\u0026quot;问题，并且插值更平滑。\n1.1. 创建四元数 using UnityEngine; // 创建四元数 Quaternion rotation = new Quaternion(x, y, z, w); 1.2. 主要属性 // 单位四元数（无旋转） Quaternion.identity // 四元数的四个分量（x, y, z, w） rotation.x rotation.y rotation.z rotation.w // 四元数的欧拉角表示 Vector3 euler = rotation.eulerAngles; 2. 创建四元数 2.1. 通过欧拉角床脚 Quaternion rot = Quaternion.Euler(30f,45f,0f); 2.2. 通过轴角创建 Quternion rot =Quaternion.AngleAxis(90f,Vector3.up); 2.3. 注视旋转 Vector3 direction =terget.position-transform.position Quaternion rot =Quaternion.LookRotation(direction); 3. 旋转运算 3.1. 组合旋转 Quaternion rot1 =Quaternion.Euler(0,90,0); Quaternion rot2 =Quaternion.Euler(30,0,0); Quaternion combined= rot1 * rot2 ;//顺序不同会产生不同结果 3.2. 旋转向量 Vector3 original =Vector3.forward; Vector3 rotated = rotation * original; 4. 插值方法 4.1. 线性插值(Lerp) // 线性插值，参数t会被钳制在[0,1] Quaternion current = transform.rotation; Quaternion target = Quaternion.Euler(0, 90, 0); transform.rotation = Quaternion.Lerp(current, target, Time.deltaTime * speed); 4.2. 球面线性插值(Slerp) // 沿球面最短路径插值，效果更平滑 transform.rotation = Quaternion.Slerp(current, target, Time.deltaTime * speed); 5. 实用方法 5.1. 从from方向到to方向的旋转 // 计算从from方向到to方向的旋转 Quaternion rot = Quaternion.FromToRotation(Vector3.up, surfaceNormal); 5.2. 点乘（相似度） // 返回两个旋转的相似度（1表示相同，-1表示相反） float similarity = Quaternion.Dot(rot1, rot2); 5.3. 逆旋转 Quaternion inverse = Quaternion.Inverse(rotation); 6. 与Transform的关系 // 获取旋转 Quaternion rot = transform.rotation; // 世界空间旋转 Quaternion localRot = transform.localRotation; // 局部空间旋转 // 设置旋转 transform.rotation = newRotation; 7. 注意事项 四元数需要规范化：Unity会自动处理，但自定义四元数时需要注意 乘法顺序：四元数乘法不满足交换律 避免直接修改eulerAngles：直接修改可能导致意外行为 插值选择：小角度旋转用Lerp，大角度用Slerp ","permalink":"https://lucasss1916.github.io/post/%E5%AD%A6%E4%B9%A0quaternion/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"学习Quaternion"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. Csharp委托（Delegate） 1.1. 委托的定义 public delegate void newDelegate(string message); public delegate int CalculateDelegate(int x, int y); 1.2. 使用委托 // 声明委托 delegate void PrintDelegate(string text); static void Main() { // 1. 传统方式实例化委托 PrintDelegate printer = new PrintDelegate(PrintMessage); printer(\u0026#34;Hello, World!\u0026#34;); // 2. 简化语法（C# 2.0+） PrintDelegate printer2 = PrintMessage; printer2(\u0026#34;Hello from simplified syntax!\u0026#34;); // 3. 匿名方法（C# 2.0） PrintDelegate printer3 = delegate(string text) { Console.WriteLine(\u0026#34;Anonymous method: \u0026#34; + text); }; printer3(\u0026#34;Testing anonymous method\u0026#34;); // 4. Lambda表达式（C# 3.0+） PrintDelegate printer4 = (text) =\u0026gt; Console.WriteLine(\u0026#34;Lambda: \u0026#34; + text); printer4(\u0026#34;Testing lambda expression\u0026#34;); } static void PrintMessage(string message) { Console.WriteLine(message); } 1.3. 多播委托 class MulticastDelegateExample { delegate void ProgressDelegate(int perfect); static void main() { ProgressDelegate progress =null; //添加多个方法到委托 progress += UpdateProgressBar; progress += LogProgress; progress += ShowNotification; progress(50); progress -=LogProgess; Console.WriteLine(\u0026#34;\\nAfter removing LogProgress: \u0026#34;); progress(75); } static void UpdateProgressBar(int percant) { Console.writeLine($\u0026#34;Progress bar updated :{percent}%\u0026#34;) } static void LogProgress(int percent) { Console.WriteLine($\u0026#34;Logging progress: {percent}%\u0026#34;); } static void ShowNotification(int percent) { Console.WriteLine($\u0026#34;Notification: Task is {percent}% complete\u0026#34;); } } 1.4. 内置委托类型 static void Main() { //1.Action\u0026lt;T\u0026gt; - 无返回值的方法 Action\u0026lt;string\u0026gt; action1 = Console.WriteLine; Action\u0026lt;int ,int\u0026gt; action2 =(x,y)=\u0026gt; Console.WriteLine($\u0026#34;sum: {x+y}\u0026#34;); action1(\u0026#34;Hello Action!\u0026#34;); action2(10,20); // 2. Func\u0026lt;T, TResult\u0026gt; - 有返回值的方法 Func\u0026lt;int, int, int\u0026gt; add = (x, y) =\u0026gt; x + y; Func\u0026lt;string, string\u0026gt; upper = s =\u0026gt; s.ToUpper(); Console.WriteLine($\u0026#34;Add result: {add(5, 3)}\u0026#34;); Console.WriteLine($\u0026#34;Upper: {upper(\u0026#34;hello\u0026#34;)}\u0026#34;); //3.Predicate\u0026lt;T\u0026gt; - 返回bool的方法 Predicate\u0026lt;int\u0026gt; isEven =x =\u0026gt;x % 2 ==0 int[] numbers ={1,2,3,4,5}; var evenNumbers= Array.FindAll(numbers,isEven); Console.WriteLine($\u0026#34;Even Numbers :{string.Join(\u0026#34;,\u0026#34;,evenNumbers)}\u0026#34;); } 1.5. 委托作为参数 ","permalink":"https://lucasss1916.github.io/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"Csharp委托和事件"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. 什么是GC 垃圾回收是自动内存管理机制，负责自动释放不再使用的内存，防止内存泄漏。\n2. 基本概念 根对象：静态字段、局部变量、CPU寄存器等 可达性：从根对象直接或间接引用的对象 代际理论：对象生存期越短，越应该被快速回收 3. Net/Unity三代GC Generation 0 ：新创建的对象15:01 Generation 1 ：存货过一次的gc对象 Generation 2: 长期存活的对象 4. GC触发时机 第0代满时 手动调用GC.Collect（） 系统内存不足 应用程序卸载域 5. 主要GC来源 using UnityEngine;\nusing System.Collections;\npublic class GCExample : MonoBehaviour\n{\nvoid Update()\n{\n// 1. 字符串拼接\nstring result = \u0026quot;Score: \u0026quot; + score + \u0026quot; Time: \u0026quot; + time; // 产生GC\n// 2. 装箱操作\nint number = 42;\nobject boxed = number; // 装箱，产生GC\n// 3. LINQ查询\nvar filtered = someList.Where(x =\u0026gt; x \u0026gt; 10).ToList(); // 产生GC\n// 4. 匿名方法/Lambda\nsomeList.ForEach(x =\u0026gt; Debug.Log(x)); // 可能产生GC\n// 5. 数组分配\nVector3[] tempArray = new Vector3[100]; // 产生GC\n}\n}\n6. GC优化技巧 6.1. 避免在循环中分配内存 6.2. 使用对象池，避免频繁的Instantiate/Destory 6.3. 避免装箱操作 6.4. 缓存组件和对象 6.5. 使用结构体替代类 6.6. 使用Array代替List 6.7. 避免在update中使用Find ","permalink":"https://lucasss1916.github.io/post/gc/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"GC"},{"categories":[{"LinkTitle":"Unity","RelPermalink":"/categories/unity/"}],"content":"Dotween官网 1. 什么是Dotween 是一个轻量级、快速、高效的补间动画引擎，用于 Unity 中创建各种动画效果。\n1.1. 主要特点 性能优秀：比 Unity 自带的 Animation 更高效\n链式语法：流畅的代码编写体验\n功能丰富：支持多种动画类型和缓动函数\n易于学习：API 设计直观\n2. 核心概念 2.1. 基本动画类型 // 安装后需要在代码中初始化 using DG.Tweening; void Start() { DOTween.Init(); } // 移动 transform.DOMove(new Vector3(5, 0, 0), 2f); // 旋转 transform.DORotate(new Vector3(0, 180, 0), 1f); // 缩放 transform.DOScale(new Vector3(2, 2, 2), 1f); // 颜色渐变 spriteRenderer.DOColor(Color.red, 1f); 2.2. 链式调用 transform.DOMove(new Vector3(5, 0, 0), 2f) .SetEase(Ease.OutBounce) // 设置缓动类型 .SetDelay(1f) // 延迟1秒 .OnComplete(() =\u0026gt; { // 完成回调 Debug.Log(\u0026#34;动画完成！\u0026#34;); }); 2.3. Sequence Sequence mySequence = DOTween.Sequence(); // 按顺序执行动画 mySequence.Append(transform.DOMoveX(5, 1f)); mySequence.Append(transform.DORotate(new Vector3(0, 180, 0), 1f)); // 同时执行动画 mySequence.Join(transform.DOScale(new Vector3(2, 2, 2), 1f)); // 等待间隔 mySequence.AppendInterval(0.5f); 3. 常用API 3.1. 基本动画 // 位置动画 DOMove(), DOLocalMove() DOMoveX(), DOMoveY(), DOMoveZ() // 旋转动画 DORotate(), DOLocalRotate() // 缩放动画 DOScale(), DOScaleX(), DOScaleY(), DOScaleZ() // UI 动画 // 需要引入 DG.Tweening.UI 命名空间 DOFade(), DOColor(), DOFillAmount() 3.2. 控制方法 Tween myTween = transform.DOMoveX(5, 2f); myTween.Play(); // 播放 myTween.Pause(); // 暂停 myTween.Restart(); // 重新开始 myTween.Kill(); // 停止并销毁 myTween.Complete(); // 立即完成 3.3. 缓动函数 // 线性 SetEase(Ease.Linear) // 平滑进入/退出 SetEase(Ease.InSine) SetEase(Ease.OutSine) SetEase(Ease.InOutSine) // 弹性效果 SetEase(Ease.InElastic) SetEase(Ease.OutElastic) // 弹跳效果 SetEase(Ease.InBounce) SetEase(Ease.OutBounce) // 自定义曲线 SetEase(AnimationCurve) 4. 实用案例 4.1. 按钮点击效果 public class ButtonAnimation : MonoBehaviour { public void OnButtonClick() { transform.DOScale(new Vector3(1.2f, 1.2f, 1.2f), 0.2f) .SetEase(Ease.OutBack) .OnComplete(() =\u0026gt; { transform.DOScale(Vector3.one, 0.1f); }); } } 4.2. 对象淡入淡出 public class FadeObject : MonoBehaviour { public CanvasGroup canvasGroup; public void FadeIn() { canvasGroup.DOFade(1, 0.5f); } public void FadeOut() { canvasGroup.DOFade(0, 0.5f); } } 4.3. 路径移动 public class PathMovement : MonoBehaviour { public Transform[] waypoints; void Start() { Vector3[] path = new Vector3[waypoints.Length]; for (int i = 0; i \u0026lt; waypoints.Length; i++) { path[i] = waypoints[i].position; } transform.DOPath(path, 5f, PathType.CatmullRom) .SetLookAt(0.01f); } } 5. Warning WARNING: on iOS safeMode works only if stripping level is set to \u0026ldquo;Strip Assemblies\u0026rdquo; or Script Call Optimization is set to \u0026ldquo;Slow and Safe\u0026rdquo;, while on Windows 10 WSA it won\u0026rsquo;t work if Master Configuration and .NET are selected.\n5.1. 在 iOS 平台上，safeMode 只有在满足以下 任一 条件时才能工作： Stripping Level 设置为 \u0026quot;Strip Assemblies\u0026quot;。 Script Call Optimization 设置为 \u0026quot;Slow and Safe\u0026quot;。 背景与现状（重要）： 这句话提到的设置项其实比较 老旧（属于 Unity 较早版本的术语）。 Script Call Optimization: 以前 Unity iOS 设置里有 \u0026ldquo;Fast but no Exceptions\u0026rdquo;（快但不处理异常）和 \u0026ldquo;Slow and Safe\u0026rdquo;（慢但安全）。如果你选了前者，Unity 会直接忽略异常捕获，导致 DOTween 的 try-catch 代码失效，safeMode 自然也就没用了。 在现代 Unity (2019/2020/2021+) 中： 这些选项已经被 IL2CPP 的设置取代。如果你使用的是 IL2CPP，通常需要关注 Player Settings 中的 \u0026ldquo;Enable Exceptions\u0026rdquo; 或类似的设置。如果设置为 \u0026ldquo;None\u0026rdquo; 或极度优化，可能会导致类似问题。 5.2. 在 Windows 10 WSA（通用 Windows 平台 / UWP）上，如果你同时满足以下两个条件，safeMode 将 无法工作： 构建配置选了 Master Configuration（这是 UWP 的最终发布模式，不包含调试信息）。 脚本后端选了 .NET（非 IL2CPP）。 原因： 在这种极端优化的发布环境下，.NET Native 编译链可能会剥离掉 DOTween 需要的反射或异常处理机制。 ","permalink":"https://lucasss1916.github.io/post/%E5%AD%A6%E4%B9%A0dotween/","tags":[{"LinkTitle":"Unity","RelPermalink":"/tags/unity/"},{"LinkTitle":"Dotween","RelPermalink":"/tags/dotween/"}],"title":"学习Dotween"},{"categories":[{"LinkTitle":"Unity","RelPermalink":"/categories/unity/"}],"content":"在测试的时候突然发现，人物摄像头会穿过其他模型直接透过去，在游戏里应该是个比较常见的问题，一开始通过放大模型的boxcollider来防止穿模，但是感觉还有更好的处理办法，询问DS老师，发现有以下几个方法：\n1. 增大碰撞体 这是最直接，也是最方便的直接拉大碰撞体，不给模型穿模的机会\n2. 使用Continuous或Continuous Dynamic碰撞检测 通过设置Rigidbody组件中的Collision Detection属性 Discrete（离散）： 默认值。性能最好，但高速物体容易穿模。 Continuous（连续）： 用于防止该物体与其他静态网格碰撞器穿模。性能开销中等。 Continuous Dynamic（连续动态）： 用于防止该物体与其他动态物体（也设置了Continuous或Continuous Dynamic）穿模。性能开销最大。\n建议：只给高速移动的物体（如子弹、玩家角色、高速飞行的道具）设置 Continuous Dynamic，给静态但复杂的网格碰撞器设置 Continuous。不要滥用，否则会严重影响性能。 3. 优化角色控制器 1.如果使用的是CharacterController则调整slope Limit（坡度限制）和 step Offset（台阶高度 2.使用Rigidbody + CapsuleCollider\n4. 更改移动逻辑 添加代码判断与物体之间的距离，达到一定距离后，使用代码限制移动 更高级的方案：Physics.SphereCast 或 Physics.CapsuleCast（还没测试过）\n这些方法比 Raycast 更精确，因为它们考虑了碰撞体的体积，能更好地模拟角色本身的形状进行预测 5. 图层碰撞矩阵 方法：进入 Edit -\u0026gt; Project Settings -\u0026gt; Physics，查看 Layer Collision Matrix。 使用：你可以创建不同的图层（Layer），例如“Player”、“Enemy”、“Environment”、“Ignore Raycast”等。然后在这个矩阵中，取消勾选不需要相互碰撞的图层。例如，你可能不希望两个玩家之间发生物理碰撞，就可以取消Player层与Player层的勾选。 6. 优化美术资源 不使用meshcollider，不勾选convex（计算成本很高） 使用原始碰撞体拼接 ","permalink":"https://lucasss1916.github.io/post/unity%E7%A9%BF%E6%A8%A1%E9%97%AE%E9%A2%98/","tags":[{"LinkTitle":"Unity","RelPermalink":"/tags/unity/"}],"title":"Unity穿模问题"},{"categories":[],"content":"关于我 这是lucas的个人博客，记录我的学习生活\n","permalink":"https://lucasss1916.github.io/about/","tags":[],"title":"关于"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. 封装 (符合开闭原则1) 将数据和方法打包到类中，并对外隐藏内部细节，通过访问修饰符控制暴露的程度。（如private，public，protected）\n2. 继承 子类可以继承父类的属性和方法，并可以扩展和重写这些功能\n3. 多态 同一操作作用于不同的对象，可以产生不同的执行结果。简单说就是“一个接口，多种实现”。\n开闭原则：对于扩展开放，对于修改关闭\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://lucasss1916.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"面向对象的三大特点"},{"categories":[{"LinkTitle":"Blog","RelPermalink":"/categories/blog/"}],"content":"1.下载安装hugo 1.在macos上安装hugo\nbrew install hugo 2.查看是否安装完成\nhugo version 3.如果正确输出.\n比如v0.133.1+extended darwin/amd64 则表示安装成功.\n2.创建blog hugo new site hugo-blog cd hugo-blog 创建主题\ngit init git submoudle add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 修改配置hugo.toml\nlanguageCode = \u0026#34;en-us\u0026#34;` title = \u0026#34;My Hugo Blog\u0026#34; theme = \u0026#34;PaperMod\u0026#34; 新建一篇文章\nhugo new posts/hello-world.md 本地预览,可通过1313端口访问\nhugo server -D ","permalink":"https://lucasss1916.github.io/post/%E4%BD%BF%E7%94%A8hugo%E5%92%8Cgithub%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BAblog/","tags":[{"LinkTitle":"Blog","RelPermalink":"/tags/blog/"}],"title":"部署blog"},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/manifest.json","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.de/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.es/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.fr/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.hi/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.jp/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.nl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.pl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.ru/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.zh-cn/","tags":[],"title":""}]