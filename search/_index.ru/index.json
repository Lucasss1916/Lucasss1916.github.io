[{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"什么是四元数？ 四元数是一种表示三维空间旋转的数学工具，与欧拉角相比，它可以避免\u0026quot;万向节锁\u0026quot;问题，并且插值更平滑。\n创建四元数 using UnityEngine; // 创建四元数 Quaternion rotation = new Quaternion(x, y, z, w); 主要属性 // 单位四元数（无旋转） Quaternion.identity // 四元数的四个分量（x, y, z, w） rotation.x rotation.y rotation.z rotation.w // 四元数的欧拉角表示 Vector3 euler = rotation.eulerAngles; 创建四元数 通过欧拉角床脚 Quaternion rot = Quaternion.Euler(30f,45f,0f); 通过轴角创建 Quternion rot =Quaternion.AngleAxis(90f,Vector3.up); 注视旋转 Vector3 direction =terget.position-transform.position Quaternion rot =Quaternion.LookRotation(direction); 旋转运算 组合旋转 Quaternion rot1 =Quaternion.Euler(0,90,0); Quaternion rot2 =Quaternion.Euler(30,0,0); Quaternion combined= rot1 * rot2 ;//顺序不同会产生不同结果 旋转向量 Vector3 original =Vector3.forward; Vector3 rotated = rotation * original; 插值方法 线性插值(Lerp) // 线性插值，参数t会被钳制在[0,1] Quaternion current = transform.rotation; Quaternion target = Quaternion.Euler(0, 90, 0); transform.rotation = Quaternion.Lerp(current, target, Time.deltaTime * speed); 球面线性插值(Slerp) // 沿球面最短路径插值，效果更平滑 transform.rotation = Quaternion.Slerp(current, target, Time.deltaTime * speed); 实用方法 从from方向到to方向的旋转 // 计算从from方向到to方向的旋转 Quaternion rot = Quaternion.FromToRotation(Vector3.up, surfaceNormal); 点乘（相似度） // 返回两个旋转的相似度（1表示相同，-1表示相反） float similarity = Quaternion.Dot(rot1, rot2); 逆旋转 Quaternion inverse = Quaternion.Inverse(rotation); 注意事项 四元数需要规范化：Unity会自动处理，但自定义四元数时需要注意 乘法顺序：四元数乘法不满足交换律 避免直接修改eulerAngles：直接修改可能导致意外行为 插值选择：小角度旋转用Lerp，大角度用Slerp ","permalink":"https://lucasss1916.github.io/post/%E5%AD%A6%E4%B9%A0quaternion/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"学习Quaternion"},{"categories":[],"content":"关于我 这是lucas的个人博客，记录我的学习生活\n","permalink":"https://lucasss1916.github.io/about/","tags":[],"title":"关于"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. Csharp委托（Delegate） 1.1. 委托的定义 public delegate void newDelegate(string message); public delegate int CalculateDelegate(int x, int y); 1.2. 使用委托 // 声明委托 delegate void PrintDelegate(string text); static void Main() { // 1. 传统方式实例化委托 PrintDelegate printer = new PrintDelegate(PrintMessage); printer(\u0026#34;Hello, World!\u0026#34;); // 2. 简化语法（C# 2.0+） PrintDelegate printer2 = PrintMessage; printer2(\u0026#34;Hello from simplified syntax!\u0026#34;); // 3. 匿名方法（C# 2.0） PrintDelegate printer3 = delegate(string text) { Console.WriteLine(\u0026#34;Anonymous method: \u0026#34; + text); }; printer3(\u0026#34;Testing anonymous method\u0026#34;); // 4. Lambda表达式（C# 3.0+） PrintDelegate printer4 = (text) =\u0026gt; Console.WriteLine(\u0026#34;Lambda: \u0026#34; + text); printer4(\u0026#34;Testing lambda expression\u0026#34;); } static void PrintMessage(string message) { Console.WriteLine(message); } 1.3. 多播委托 class MulticastDelegateExample { delegate void ProgressDelegate(int perfect); static void main() { ProgressDelegate progress =null; //添加多个方法到委托 progress += UpdateProgressBar; progress += LogProgress; progress += ShowNotification; progress(50); progress -=LogProgess; Console.WriteLine(\u0026#34;\\nAfter removing LogProgress: \u0026#34;); progress(75); } static void UpdateProgressBar(int percant) { Console.writeLine($\u0026#34;Progress bar updated :{percent}%\u0026#34;) } static void LogProgress(int percent) { Console.WriteLine($\u0026#34;Logging progress: {percent}%\u0026#34;); } static void ShowNotification(int percent) { Console.WriteLine($\u0026#34;Notification: Task is {percent}% complete\u0026#34;); } } 1.4. 内置委托类型 static void Main() { //1.Action\u0026lt;T\u0026gt; - 无返回值的方法 Action\u0026lt;string\u0026gt; action1 = Console.WriteLine; Action\u0026lt;int ,int\u0026gt; action2 =(x,y)=\u0026gt; Console.WriteLine($\u0026#34;sum: {x+y}\u0026#34;); action1(\u0026#34;Hello Action!\u0026#34;); action2(10,20); // 2. Func\u0026lt;T, TResult\u0026gt; - 有返回值的方法 Func\u0026lt;int, int, int\u0026gt; add = (x, y) =\u0026gt; x + y; Func\u0026lt;string, string\u0026gt; upper = s =\u0026gt; s.ToUpper(); Console.WriteLine($\u0026#34;Add result: {add(5, 3)}\u0026#34;); Console.WriteLine($\u0026#34;Upper: {upper(\u0026#34;hello\u0026#34;)}\u0026#34;); //3.Predicate\u0026lt;T\u0026gt; - 返回bool的方法 Predicate\u0026lt;int\u0026gt; isEven =x =\u0026gt;x % 2 ==0 int[] numbers ={1,2,3,4,5}; var evenNumbers= Array.FindAll(numbers,isEven); Console.WriteLine($\u0026#34;Even Numbers :{string.Join(\u0026#34;,\u0026#34;,evenNumbers)}\u0026#34;); } 1.5. 委托作为参数 ","permalink":"https://lucasss1916.github.io/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"Csharp委托和事件"},{"categories":[{"LinkTitle":"Blog","RelPermalink":"/categories/blog/"}],"content":"1.下载安装hugo 1.在macos上安装hugo\nbrew install hugo 2.查看是否安装完成\nhugo version 3.如果正确输出.\n比如v0.133.1+extended darwin/amd64 则表示安装成功.\n2.创建blog hugo new site hugo-blog cd hugo-blog 创建主题\ngit init git submoudle add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 修改配置hugo.toml\nlanguageCode = \u0026#34;en-us\u0026#34;` title = \u0026#34;My Hugo Blog\u0026#34; theme = \u0026#34;PaperMod\u0026#34; 新建一篇文章\nhugo new posts/hello-world.md 本地预览,可通过1313端口访问\nhugo server -D ","permalink":"https://lucasss1916.github.io/post/%E4%BD%BF%E7%94%A8hugo%E5%92%8Cgithub%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BAblog/","tags":[],"title":"部署blog"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. 什么是GC 垃圾回收是自动内存管理机制，负责自动释放不再使用的内存，防止内存泄漏。\n2. 基本概念 根对象：静态字段、局部变量、CPU寄存器等 可达性：从根对象直接或间接引用的对象 代际理论：对象生存期越短，越应该被快速回收 3. Net/Unity三代GC Generation 0 ：新创建的对象15:01 Generation 1 ：存货过一次的gc对象 Generation 2: 长期存活的对象 4. GC触发时机 第0代满时 手动调用GC.Collect（） 系统内存不足 应用程序卸载域 5. 主要GC来源 using UnityEngine;\nusing System.Collections;\npublic class GCExample : MonoBehaviour\n{\nvoid Update()\n{\n// 1. 字符串拼接\nstring result = \u0026quot;Score: \u0026quot; + score + \u0026quot; Time: \u0026quot; + time; // 产生GC\n// 2. 装箱操作\nint number = 42;\nobject boxed = number; // 装箱，产生GC\n// 3. LINQ查询\nvar filtered = someList.Where(x =\u0026gt; x \u0026gt; 10).ToList(); // 产生GC\n// 4. 匿名方法/Lambda\nsomeList.ForEach(x =\u0026gt; Debug.Log(x)); // 可能产生GC\n// 5. 数组分配\nVector3[] tempArray = new Vector3[100]; // 产生GC\n}\n}\n6. GC优化技巧 6.1. 避免在循环中分配内存 6.2. 使用对象池，避免频繁的Instantiate/Destory 6.3. 避免装箱操作 6.4. 缓存组件和对象 6.5. 使用结构体替代类 6.6. 使用Array代替List 6.7. 避免在update中使用Find ","permalink":"https://lucasss1916.github.io/post/gc/","tags":[{"LinkTitle":"CSharp","RelPermalink":"/tags/csharp/"}],"title":"GC"},{"categories":[{"LinkTitle":"Unity","RelPermalink":"/categories/unity/"},{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"在测试的时候突然发现，人物摄像头会穿过其他模型直接透过去，在游戏里应该是个比较常见的问题，一开始通过放大模型的boxcollider来防止穿模，但是感觉还有更好的处理办法，询问DS老师，发现有以下几个方法：\n1. 增大碰撞体 这是最直接，也是最方便的直接拉大碰撞体，不给模型穿模的机会\n2. 使用Continuous或Continuous Dynamic碰撞检测 通过设置Rigidbody组件中的Collision Detection属性 Discrete（离散）： 默认值。性能最好，但高速物体容易穿模。 Continuous（连续）： 用于防止该物体与其他静态网格碰撞器穿模。性能开销中等。 Continuous Dynamic（连续动态）： 用于防止该物体与其他动态物体（也设置了Continuous或Continuous Dynamic）穿模。性能开销最大。\n建议：只给高速移动的物体（如子弹、玩家角色、高速飞行的道具）设置 Continuous Dynamic，给静态但复杂的网格碰撞器设置 Continuous。不要滥用，否则会严重影响性能。 3. 优化角色控制器 1.如果使用的是CharacterController则调整slope Limit（坡度限制）和 step Offset（台阶高度 2.使用Rigidbody + CapsuleCollider\n4. 更改移动逻辑 添加代码判断与物体之间的距离，达到一定距离后，使用代码限制移动 更高级的方案：Physics.SphereCast 或 Physics.CapsuleCast（还没测试过）\n这些方法比 Raycast 更精确，因为它们考虑了碰撞体的体积，能更好地模拟角色本身的形状进行预测 5. 图层碰撞矩阵 方法：进入 Edit -\u0026gt; Project Settings -\u0026gt; Physics，查看 Layer Collision Matrix。 使用：你可以创建不同的图层（Layer），例如“Player”、“Enemy”、“Environment”、“Ignore Raycast”等。然后在这个矩阵中，取消勾选不需要相互碰撞的图层。例如，你可能不希望两个玩家之间发生物理碰撞，就可以取消Player层与Player层的勾选。 6. 优化美术资源 不使用meshcollider，不勾选convex（计算成本很高） 使用原始碰撞体拼接 ","permalink":"https://lucasss1916.github.io/post/unity%E7%A9%BF%E6%A8%A1%E9%97%AE%E9%A2%98/","tags":[{"LinkTitle":"Unity","RelPermalink":"/tags/unity/"}],"title":"Unity穿模问题"},{"categories":[{"LinkTitle":"C#","RelPermalink":"/categories/c%23/"}],"content":"1. 封装 (符合开闭原则1) 将数据和方法打包到类中，并对外隐藏内部细节，通过访问修饰符控制暴露的程度。（如private，public，protected）\n2. 继承 子类可以继承父类的属性和方法，并可以扩展和重写这些功能\n3. 多态 同一操作作用于不同的对象，可以产生不同的执行结果。简单说就是“一个接口，多种实现”。\n开闭原则：对于扩展开放，对于修改关闭\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://lucasss1916.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/","tags":[],"title":"面向对象的三大特点"},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/manifest.json","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.de/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.es/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.fr/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.hi/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.jp/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.nl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.pl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.ru/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://lucasss1916.github.io/search/_index.zh-cn/","tags":[],"title":""}]