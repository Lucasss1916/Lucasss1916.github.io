<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lucas的博客</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on Lucas的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <managingEditor>user@example.com (Lucas)</managingEditor>
    <webMaster>user@example.com (Lucas)</webMaster>
    <copyright>Lucas</copyright>
    <lastBuildDate>Tue, 23 Dec 2025 12:51:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Csharp委托和事件</title>
      <link>http://localhost:1313/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Tue, 23 Dec 2025 12:51:00 +0800</pubDate><author>user@example.com (Lucas)</author>
      <guid>http://localhost:1313/post/csharp%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</guid>
      <description>&lt;h1 id=&#34;1-csharp委托delegate&#34;&gt;1. Csharp委托（Delegate）&lt;/h1&gt;&#xA;&lt;h2 id=&#34;11-委托的定义&#34;&gt;1.1. 委托的定义&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public delegate void newDelegate(string message);&#xA;public delegate int CalculateDelegate(int x, int y);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;12-使用委托&#34;&gt;1.2. 使用委托&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 声明委托&#xA;    delegate void PrintDelegate(string text);&#xA;    &#xA;    static void Main()&#xA;    {&#xA;        // 1. 传统方式实例化委托&#xA;        PrintDelegate printer = new PrintDelegate(PrintMessage);&#xA;        printer(&amp;#34;Hello, World!&amp;#34;);&#xA;        &#xA;        // 2. 简化语法（C# 2.0+）&#xA;        PrintDelegate printer2 = PrintMessage;&#xA;        printer2(&amp;#34;Hello from simplified syntax!&amp;#34;);&#xA;        &#xA;        // 3. 匿名方法（C# 2.0）&#xA;        PrintDelegate printer3 = delegate(string text)&#xA;        {&#xA;            Console.WriteLine(&amp;#34;Anonymous method: &amp;#34; + text);&#xA;        };&#xA;        printer3(&amp;#34;Testing anonymous method&amp;#34;);&#xA;        &#xA;        // 4. Lambda表达式（C# 3.0+）&#xA;        PrintDelegate printer4 = (text) =&amp;gt; Console.WriteLine(&amp;#34;Lambda: &amp;#34; + text);&#xA;        printer4(&amp;#34;Testing lambda expression&amp;#34;);&#xA;    }&#xA;    static void PrintMessage(string message)&#xA;    {&#xA;        Console.WriteLine(message);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;13-多播委托&#34;&gt;1.3. 多播委托&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MulticastDelegateExample&#xA;{&#xA;&#x9;delegate void ProgressDelegate(int perfect);&#xA;&#x9;static void main()&#xA;&#x9;{&#xA;&#x9;&#x9;ProgressDelegate progress =null;&#xA;&#x9;&#x9;//添加多个方法到委托&#xA;&#x9;&#x9;progress += UpdateProgressBar;&#xA;&#x9;&#x9;progress += LogProgress;&#xA;&#x9;&#x9;progress += ShowNotification;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;progress(50);&#xA;&#x9;&#x9;progress -=LogProgess;&#xA;&#x9;&#x9;Console.WriteLine(&amp;#34;\nAfter removing LogProgress: &amp;#34;);&#xA;&#x9;&#x9;progress(75);&#xA;&#x9;}&#xA;&#x9;static void UpdateProgressBar(int percant)&#xA;&#x9;{&#xA;&#x9;&#x9; Console.writeLine($&amp;#34;Progress bar updated :{percent}%&amp;#34;)&#xA;&#x9;}&#xA;&#x9;static void LogProgress(int percent)&#xA;    {&#xA;        Console.WriteLine($&amp;#34;Logging progress: {percent}%&amp;#34;);&#xA;    }&#xA;    static void ShowNotification(int percent)&#xA;    {&#xA;        Console.WriteLine($&amp;#34;Notification: Task is {percent}% complete&amp;#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;14-内置委托类型&#34;&gt;1.4. 内置委托类型&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void  Main()&#xA;{&#xA;&#x9;//1.Action&amp;lt;T&amp;gt; -  无返回值的方法&#xA;&#x9;Action&amp;lt;string&amp;gt; action1 = Console.WriteLine;&#xA;&#x9;Action&amp;lt;int ,int&amp;gt; action2 =(x,y)=&amp;gt; Console.WriteLine($&amp;#34;sum: {x+y}&amp;#34;);&#xA;&#x9;action1(&amp;#34;Hello Action!&amp;#34;);&#xA;&#x9;action2(10,20);&#xA;    // 2. Func&amp;lt;T, TResult&amp;gt; - 有返回值的方法&#xA;    Func&amp;lt;int, int, int&amp;gt; add = (x, y) =&amp;gt; x + y;&#xA;    Func&amp;lt;string, string&amp;gt; upper = s =&amp;gt; s.ToUpper();&#xA;    &#xA;    Console.WriteLine($&amp;#34;Add result: {add(5, 3)}&amp;#34;);&#xA;    Console.WriteLine($&amp;#34;Upper: {upper(&amp;#34;hello&amp;#34;)}&amp;#34;);&#xA;&#x9;//3.Predicate&amp;lt;T&amp;gt; - 返回bool的方法&#xA;&#x9;Predicate&amp;lt;int&amp;gt; isEven =x =&amp;gt;x % 2 ==0&#xA;&#x9;int[] numbers ={1,2,3,4,5};&#xA;&#x9;&#xA;&#x9;var evenNumbers= Array.FindAll(numbers,isEven);&#xA;&#x9;Console.WriteLine($&amp;#34;Even Numbers :{string.Join(&amp;#34;,&amp;#34;,evenNumbers)}&amp;#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;15-委托作为参数&#34;&gt;1.5. 委托作为参数&lt;/h2&gt;</description>
    </item>
    <item>
      <title>部署blog</title>
      <link>http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E5%92%8Cgithub%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BAblog/</link>
      <pubDate>Sun, 31 Aug 2025 17:04:19 +0800</pubDate><author>user@example.com (Lucas)</author>
      <guid>http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E5%92%8Cgithub%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BAblog/</guid>
      <description>&lt;h1 id=&#34;1下载安装hugo&#34;&gt;1.下载安装hugo&lt;/h1&gt;&#xA;&lt;p&gt;1.在macos上安装hugo&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;brew install hugo&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.查看是否安装完成&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hugo version&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.如果正确输出.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;比如v0.133.1+extended darwin/amd64&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则表示安装成功.&lt;/p&gt;&#xA;&lt;h1 id=&#34;2创建blog&#34;&gt;2.创建blog&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hugo new site hugo-blog  &#xA;cd hugo-blog&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建主题&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git init &#xA;git submoudle add &#xA;&#x9;https://github.com/adityatelange/hugo-PaperMod.git&#xA;themes/PaperMod   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置hugo.toml&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-baseURL&#34; data-lang=&#34;baseURL&#34;&gt;languageCode = &amp;#34;en-us&amp;#34;`  &#xA;title = &amp;#34;My Hugo Blog&amp;#34;   &#xA;theme = &amp;#34;PaperMod&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一篇文章&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hugo new posts/hello-world.md&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本地预览,可通过1313端口访问&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hugo server -D&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>GC</title>
      <link>http://localhost:1313/post/gc/</link>
      <pubDate>Tue, 19 Aug 2025 21:56:01 +0800</pubDate><author>user@example.com (Lucas)</author>
      <guid>http://localhost:1313/post/gc/</guid>
      <description>&lt;h1 id=&#34;1-什么是gc&#34;&gt;1. 什么是GC&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;是自动内存管理机制，负责自动释放不再使用的内存，防止内存泄漏。&lt;/p&gt;&#xA;&lt;h1 id=&#34;2-基本概念&#34;&gt;2. 基本概念&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;根对象&lt;/strong&gt;：静态字段、局部变量、CPU寄存器等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可达性&lt;/strong&gt;：从根对象直接或间接引用的对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;代际理论&lt;/strong&gt;：对象生存期越短，越应该被快速回收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;3-netunity三代gc&#34;&gt;3. Net/Unity三代GC&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Generation 0 ：新创建的对象15:01&lt;/li&gt;&#xA;&lt;li&gt;Generation 1 ：存货过一次的gc对象&lt;/li&gt;&#xA;&lt;li&gt;Generation 2: 长期存活的对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;4-gc触发时机&#34;&gt;4. GC触发时机&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第0代满时&lt;/li&gt;&#xA;&lt;li&gt;手动调用GC.Collect（）&lt;/li&gt;&#xA;&lt;li&gt;系统内存不足&lt;/li&gt;&#xA;&lt;li&gt;应用程序卸载域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;5-主要gc来源&#34;&gt;5. 主要GC来源&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;using UnityEngine;&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;using System.Collections;&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;public class GCExample : MonoBehaviour&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;{&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;void Update()&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;{&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;// 1. 字符串拼接&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;string result = &amp;quot;Score: &amp;quot; + score + &amp;quot; Time: &amp;quot; + time; // 产生GC&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;// 2. 装箱操作&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;int number = 42;&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;object boxed = number; // 装箱，产生GC&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;// 3. LINQ查询&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;var filtered = someList.Where(x =&amp;gt; x &amp;gt; 10).ToList(); // 产生GC&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;// 4. 匿名方法/Lambda&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;someList.ForEach(x =&amp;gt; Debug.Log(x)); // 可能产生GC&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;// 5. 数组分配&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;Vector3[] tempArray = new Vector3[100]; // 产生GC&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;&#xA;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity穿模问题</title>
      <link>http://localhost:1313/post/unity%E7%A9%BF%E6%A8%A1%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 14 Aug 2025 15:25:30 +0800</pubDate><author>user@example.com (Lucas)</author>
      <guid>http://localhost:1313/post/unity%E7%A9%BF%E6%A8%A1%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;在测试的时候突然发现，人物摄像头会穿过其他模型直接透过去，在游戏里应该是个比较常见的问题，一开始通过放大模型的boxcollider来防止穿模，但是感觉还有更好的处理办法，询问DS老师，发现有以下几个方法：&lt;/p&gt;&#xA;&lt;h1 id=&#34;1-增大碰撞体&#34;&gt;1. 增大碰撞体&lt;/h1&gt;&#xA;&lt;p&gt;这是最直接，也是最方便的直接拉大碰撞体，不给模型穿模的机会&lt;/p&gt;&#xA;&lt;h1 id=&#34;2-使用continuous或continuous-dynamic碰撞检测&#34;&gt;2. 使用&lt;code&gt;Continuous&lt;/code&gt;或&lt;code&gt;Continuous Dynamic&lt;/code&gt;碰撞检测&lt;/h1&gt;&#xA;&lt;p&gt;通过设置Rigidbody组件中的Collision Detection属性&#xA;Discrete（离散）： 默认值。性能最好，但高速物体容易穿模。&#xA;Continuous（连续）： 用于防止该物体与其他静态网格碰撞器穿模。性能开销中等。&#xA;Continuous Dynamic（连续动态）： 用于防止该物体与其他动态物体（也设置了Continuous或Continuous Dynamic）穿模。性能开销最大。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：只给&lt;strong&gt;高速移动的物体&lt;/strong&gt;（如子弹、玩家角色、高速飞行的道具）设置 &lt;code&gt;Continuous Dynamic&lt;/code&gt;，给静态但复杂的网格碰撞器设置 &lt;code&gt;Continuous&lt;/code&gt;。不要滥用，否则会严重影响性能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;3-优化角色控制器&#34;&gt;3. 优化角色控制器&lt;/h1&gt;&#xA;&lt;p&gt;1.如果使用的是&lt;code&gt;CharacterController&lt;/code&gt;则调整&lt;code&gt;slope Limit&lt;/code&gt;（坡度限制）和 &lt;code&gt;step Offset&lt;/code&gt;（台阶高度&#xA;2.使用&lt;code&gt;Rigidbody&lt;/code&gt; + &lt;code&gt;CapsuleCollider&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;4-更改移动逻辑&#34;&gt;4. 更改移动逻辑&lt;/h1&gt;&#xA;&lt;p&gt;添加代码判断与物体之间的距离，达到一定距离后，使用代码限制移动&#xA;更高级的方案：&lt;code&gt;Physics.SphereCast&lt;/code&gt; 或 &lt;code&gt;Physics.CapsuleCast&lt;/code&gt;（还没测试过）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这些方法比 &lt;code&gt;Raycast&lt;/code&gt; 更精确，因为它们考虑了碰撞体的体积，能更好地模拟角色本身的形状进行预测&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;5-图层碰撞矩阵&#34;&gt;5. 图层碰撞矩阵&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：进入 &lt;code&gt;Edit -&amp;gt; Project Settings -&amp;gt; Physics&lt;/code&gt;，查看 &lt;code&gt;Layer Collision Matrix&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt;：你可以创建不同的图层（Layer），例如“Player”、“Enemy”、“Environment”、“Ignore Raycast”等。然后在这个矩阵中，取消勾选不需要相互碰撞的图层。例如，你可能不希望两个玩家之间发生物理碰撞，就可以取消Player层与Player层的勾选。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;6-优化美术资源&#34;&gt;6. 优化美术资源&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不使用meshcollider，不勾选convex（计算成本很高）&lt;/li&gt;&#xA;&lt;li&gt;使用原始碰撞体拼接&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>面向对象的三大特点</title>
      <link>http://localhost:1313/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/</link>
      <pubDate>Tue, 10 Jun 2025 17:02:19 +0800</pubDate><author>user@example.com (Lucas)</author>
      <guid>http://localhost:1313/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/</guid>
      <description>封装，继承，多态</description>
    </item>
  </channel>
</rss>
